// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
/* Copyright (c) 2022 Jacky Yin */
/* Copyright (c) 2025 Will Hawkins (Cerfcast) */
#include "sockfilter.h"
#include "sockfilter.skel.h"
#include <arpa/inet.h>
#include <bpf/libbpf.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/in.h>
#include <net/if.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdio.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <unistd.h>

static int open_raw_sock(const char *name) {
  struct sockaddr_ll sll;
  int sock;

  sock = socket(PF_PACKET, SOCK_RAW | SOCK_NONBLOCK | SOCK_CLOEXEC,
                htons(ETH_P_ALL));
  if (sock < 0) {
    fprintf(stderr, "Failed to create raw socket\n");
    return -1;
  }

  memset(&sll, 0, sizeof(sll));
  sll.sll_family = AF_PACKET;
  sll.sll_ifindex = if_nametoindex(name);
  sll.sll_protocol = htons(ETH_P_ALL);
  if (bind(sock, (struct sockaddr *)&sll, sizeof(sll)) < 0) {
    fprintf(stderr, "Failed to bind to %s: %s\n", name, strerror(errno));
    close(sock);
    return -1;
  }

  return sock;
}

static int libbpf_print_fn(enum libbpf_print_level level, const char *format,
                           va_list args) {
  return vfprintf(stderr, format, args);
}

static int handle_event(void *processor, void *data, size_t data_sz) {
  packet_processor_t actual_processor = (packet_processor_t)processor;

  const struct so_event *e = data;
  char ifname[IF_NAMESIZE];
  char sstr[16] = {}, dstr[16] = {};

  if (e->pkt_type != PACKET_HOST)
    return 0;

  if (e->ip_proto != IPPROTO_ICMP)
    return 0;

  if (!if_indextoname(e->ifindex, ifname))
    return 0;

  // If everything looks okay, then call the registered callback.
  actual_processor(e, 0, NULL);

  return 0;
}

volatile bool exiting = false;

static void sig_handler(int sig) { exiting = true; }

int filter(packet_processor_t processor) {
  struct ring_buffer *rb = NULL;
  struct sockfilter_bpf *skel;
  int err, prog_fd, sock;

  // Set up libbpf errors and debug info callback
  libbpf_set_print(libbpf_print_fn);

  // Cleaner handling of Ctrl-C
  signal(SIGINT, sig_handler);
  signal(SIGTERM, sig_handler);

  // Load and verify BPF programs
  skel = sockfilter_bpf__open_and_load(); // This function is autogenerated by
                                          // libbpf.
  if (!skel) {
    fprintf(stderr, "Failed to open and load BPF skeleton\n");
    return 1;
  }

  // Set up ring buffer polling (where handle_event is the handler.)
  rb = ring_buffer__new(bpf_map__fd(skel->maps.rb), handle_event, processor,
                        NULL);
  if (!rb) {
    err = -1;
    fprintf(stderr, "Failed to create ring buffer\n");
    goto cleanup;
  }

  // Create raw socket for localhost interface
  // TODO: Parameterize here.
  sock = open_raw_sock("lo");
  if (sock < 0) {
    err = -2;
    fprintf(stderr, "Failed to open raw socket\n");
    goto cleanup;
  }

  // Attach BPF program to raw socket
  prog_fd = bpf_program__fd(skel->progs.socket_handler);
  if (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(prog_fd))) {
    err = -3;
    fprintf(stderr, "Failed to attach to raw socket\n");
    goto cleanup;
  }

  // Process events
  while (!exiting) {
    err = ring_buffer__poll(
        rb, 100 /* timeout, ms */); // TODO: Parameterize timeout(s)
    /* Ctrl-C will cause -EINTR */
    if (err == -EINTR) {
      err = 0;
      break;
    }
    if (err < 0) {
      fprintf(stderr, "Error polling perf buffer: %d\n", err);
      break;
    }
    sleep(1);
  }

cleanup:
  ring_buffer__free(rb);
  sockfilter_bpf__destroy(skel);
  return -err;
}
